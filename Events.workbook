---
uti: com.xamarin.workbook
platform: iOS
packages: []
---

# Events

First letâ€™s make a button on the screen and see how we can handle click events:

```csharp
var window = new UIWindow(UIScreen.MainScreen.Bounds);
window.MakeKeyAndVisible();
var controller = new UIViewController();
window.RootViewController = controller;
var button = UIButton.FromType(UIButtonType.System);
button.Frame = new CGRect(10, 200, controller.View.Bounds.Width - 20, 31.0f);
button.SetTitle ("Submit", UIControlState.Normal);
controller.Add(button);
```

In C# ther are no anonymous inner classes, but there is a nice eventing system. There are 3 ways to add a handler on a touch event:

## Anonymous Delegate

```csharp
button.TouchUpInside += delegate {
  new UIAlertView("Touch", "You touched me!", null, "OK", null).Show();
};
```

## Lambda Expression

```csharp
button.TouchUpInside += (sender, ea) => {
  new UIAlertView("Touch", "Handled by a Lambda", null, "OK", null).Show();
};
```

## Assign a delegate method

```csharp
void HandleTouchUpInside (object sender, EventArgs ea) {
    new UIAlertView("Touch", "Handled by a delegate method", null, "OK", null).Show();
}

button.TouchUpInside += HandleTouchUpInside;
```

In this last case we can also remove the handler like this:

```csharp
button.TouchUpInside -= HandleTouchUpInside;
```

Invoking a event for yourself, to setup a you'll need a bit boilerplate:

```csharp
public class Event
{
  public delegate void CustomEventHandler(object sender, EventArgs e);

  public event CustomEventHandler CustomEvent;

  public void InvokeEvent()
  {
    // Invoke the event from within the class that declared the event:
    CustomEvent(this, EventArgs.Empty);
  }
}
```

Then to "listen" to the event:
```csharp
var e = new Event();

e.CustomEvent += new Event.CustomEventHandler((sender, args) =>
    new UIAlertView("CustomEvent", "Fired by a custom event", null, "OK", null).Show());
```

```csharp
e.InvokeEvent();
```

# Operator Overloading

Like C++, C# allows you to overload operators for use on your own classes. This makes it possible for a user-defined data type to look as natural and be as logical to use as a fundamental data type. Here is an example of a `ComplexNumber` that has a `+` and `-` operator defined.

```csharp
public class ComplexNumber
{
  private readonly int _real;
  private readonly int _imaginary;

  public ComplexNumber(int r, int i)
  {
    _real = r;
    _imaginary = i;
  }

  public override string ToString()
  {
    return $"{_real} + {_imaginary}i";
  }

  // Overloading '+' operator:
  public static ComplexNumber operator +(ComplexNumber a, ComplexNumber b)
  {
    return new ComplexNumber(a._real + b._real, a._imaginary + b._imaginary);
  }

  // Overloading '-' operator:
  public static ComplexNumber operator -(ComplexNumber a, ComplexNumber b)
  {
    return new ComplexNumber(a._real - b._real, a._imaginary - b._imaginary);
  }
}
```

To use it:

```csharp
var a = new ComplexNumber(10, 12);
var b = new ComplexNumber(8, 9);

var sum = a + b;
Console.WriteLine("Complex Number sum = {0}", sum);
```

